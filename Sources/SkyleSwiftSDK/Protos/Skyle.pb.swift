// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Skyle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// Full protocol that is used to interface with the Skyle eye tracker with gRPC
///
/// (c) 2020 eyeV GmbH, written by Mathias Anhalt
///
/// https://eyev.de/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Message to request resets
public struct Skyle_ResetMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///restart services (including gRPC server)
  public var services: Bool = false

  ///restart the whole device (takes up to 30 secs)
  public var device: Bool = false

  ///reset saved user data and calibs. WARNING! ONLY DO THIS WHEN YOU REALLY WANT TO DELETE ALL USER DATA!
  public var data: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message describing a user profile
public struct Skyle_Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Unique ID for a user (on this eye tracker)
  public var id: Int32 = 0

  ///Name or nickname for the profile
  public var name: String = String()

  ///Skill of user
  public var skill: Skyle_Profile.Skill = .low

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Skill: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    ///User is unpractised and has maybe cognitive impairment. this will cause the eye tracker to filter gaze data harder (less precision)
    case low // = 0

    ///User that understands the operation. Default filtering will take place
    case medium // = 1

    ///User that is experienced with eye tracking and wants to control the filtering himself
    case high // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .low
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .low
      case 1: self = .medium
      case 2: self = .high
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .low: return 0
      case .medium: return 1
      case .high: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Skyle_Profile.Skill: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Skyle_Profile.Skill] = [
    .low,
    .medium,
    .high,
  ]
}

#endif  // swift(>=4.2)

///*
/// General status message
public struct Skyle_StatusMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///True on success, false on failure
  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message to wrap the options message: either empty or filled with options
public struct Skyle_OptionMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Skyle_OptionMessage.OneOf_Message? = nil

  ///Empty message
  public var empty: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .empty(let v)? = message {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {message = .empty(newValue)}
  }

  ///Options
  public var options: Skyle_Options {
    get {
      if case .options(let v)? = message {return v}
      return Skyle_Options()
    }
    set {message = .options(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    ///Empty message
    case empty(SwiftProtobuf.Google_Protobuf_Empty)
    ///Options
    case options(Skyle_Options)

  #if !swift(>=4.1)
    public static func ==(lhs: Skyle_OptionMessage.OneOf_Message, rhs: Skyle_OptionMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.empty(let l), .empty(let r)): return l == r
      case (.options(let l), .options(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// Message wrapping possible calibration control messages for a client
public struct Skyle_calibControlMessages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Skyle_calibControlMessages.OneOf_Message? = nil

  ///Message describing the calibration status
  public var calibControl: Skyle_CalibControl {
    get {
      if case .calibControl(let v)? = message {return v}
      return Skyle_CalibControl()
    }
    set {message = .calibControl(newValue)}
  }

  ///Message to improve a calibration
  public var calibImprove: Skyle_CalibImprove {
    get {
      if case .calibImprove(let v)? = message {return v}
      return Skyle_CalibImprove()
    }
    set {message = .calibImprove(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    ///Message describing the calibration status
    case calibControl(Skyle_CalibControl)
    ///Message to improve a calibration
    case calibImprove(Skyle_CalibImprove)

  #if !swift(>=4.1)
    public static func ==(lhs: Skyle_calibControlMessages.OneOf_Message, rhs: Skyle_calibControlMessages.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.calibControl(let l), .calibControl(let r)): return l == r
      case (.calibImprove(let l), .calibImprove(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// Message describing the calibration status
public struct Skyle_CalibControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Indicates a running calibration or requests a calibration
  public var calibrate: Bool = false

  ///Number of calibration points, currently 5 and 9 is accepted
  public var numberOfPoints: Int32 = 0

  ///Indicates an aborted calibration or request an abort
  public var abort: Bool = false

  ///If connected to an iPad or tablet, this will indicate if the native cursor should move or not
  public var stopHid: Bool = false

  ///Screen resolution of the client: set this to the native client resolution (if unset, internal resolutions will be used)
  public var res: Skyle_ScreenResolution {
    get {return _res ?? Skyle_ScreenResolution()}
    set {_res = newValue}
  }
  /// Returns true if `res` has been explicitly set.
  public var hasRes: Bool {return self._res != nil}
  /// Clears the value of `res`. Subsequent reads from it will return its default value.
  public mutating func clearRes() {self._res = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _res: Skyle_ScreenResolution? = nil
}

///*
/// Message with screen resolution of the client
public struct Skyle_ScreenResolution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Width in pixel
  public var width: Int32 = 0

  ///Height in pixel
  public var height: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message to improve a calibration
public struct Skyle_CalibImprove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Improve points that are worse than this rating (1-5)
  public var rating: Int32 = 0

  ///If connected to an iPad or tablet, this will indicate if the native cursor should move or not
  public var stopHid: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message wrapping calibration host messages
public struct Skyle_CalibMessages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Skyle_CalibMessages.OneOf_Message? = nil

  ///Message describing the calibration status, gets sent on change
  public var calibControl: Skyle_CalibControl {
    get {
      if case .calibControl(let v)? = message {return v}
      return Skyle_CalibControl()
    }
    set {message = .calibControl(newValue)}
  }

  ///Calibration point that gets sent on change
  public var calibPoint: Skyle_CalibPoint {
    get {
      if case .calibPoint(let v)? = message {return v}
      return Skyle_CalibPoint()
    }
    set {message = .calibPoint(newValue)}
  }

  ///Calibration quality, gets sent when calibration is done
  public var calibQuality: Skyle_CalibQuality {
    get {
      if case .calibQuality(let v)? = message {return v}
      return Skyle_CalibQuality()
    }
    set {message = .calibQuality(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    ///Message describing the calibration status, gets sent on change
    case calibControl(Skyle_CalibControl)
    ///Calibration point that gets sent on change
    case calibPoint(Skyle_CalibPoint)
    ///Calibration quality, gets sent when calibration is done
    case calibQuality(Skyle_CalibQuality)

  #if !swift(>=4.1)
    public static func ==(lhs: Skyle_CalibMessages.OneOf_Message, rhs: Skyle_CalibMessages.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.calibControl(let l), .calibControl(let r)): return l == r
      case (.calibPoint(let l), .calibPoint(let r)): return l == r
      case (.calibQuality(let l), .calibQuality(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// Message for a 2D point
public struct Skyle_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Precise X value
  public var x: Double = 0

  ///Precise Y value
  public var y: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message describing a calibration point
public struct Skyle_CalibPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Number of calibration point: 0 to 8 for 9 point calibration, 0 to 4 for 5 point calibration
  public var count: Int32 = 0

  ///2D point with coordinates
  public var currentPoint: Skyle_Point {
    get {return _currentPoint ?? Skyle_Point()}
    set {_currentPoint = newValue}
  }
  /// Returns true if `currentPoint` has been explicitly set.
  public var hasCurrentPoint: Bool {return self._currentPoint != nil}
  /// Clears the value of `currentPoint`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPoint() {self._currentPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentPoint: Skyle_Point? = nil
}

///*
/// Message describing the quality of a calibration
public struct Skyle_CalibQuality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Overall quality: 1 is worst, 5 is best
  public var quality: Double = 0

  ///List of quality per calibration point: 1 is worst, 5 is best
  public var qualitys: [Double] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message with eye positions and quality indicators
public struct Skyle_PositioningMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2D position of the left eye
  public var leftEye: Skyle_Point {
    get {return _leftEye ?? Skyle_Point()}
    set {_leftEye = newValue}
  }
  /// Returns true if `leftEye` has been explicitly set.
  public var hasLeftEye: Bool {return self._leftEye != nil}
  /// Clears the value of `leftEye`. Subsequent reads from it will return its default value.
  public mutating func clearLeftEye() {self._leftEye = nil}

  ///2D position of the right eye
  public var rightEye: Skyle_Point {
    get {return _rightEye ?? Skyle_Point()}
    set {_rightEye = newValue}
  }
  /// Returns true if `rightEye` has been explicitly set.
  public var hasRightEye: Bool {return self._rightEye != nil}
  /// Clears the value of `rightEye`. Subsequent reads from it will return its default value.
  public mutating func clearRightEye() {self._rightEye = nil}

  ///Quality indicator for depth positioning. range is -50 to +50. 0 is the best, -50 to far away and 50 to close
  public var qualityDepth: Int32 = 0

  ///Quality indicator for side positioning. range is -50 to +50. 0 is the best, -50 to far left and 50 to far right
  public var qualitySides: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _leftEye: Skyle_Point? = nil
  fileprivate var _rightEye: Skyle_Point? = nil
}

///*
/// Option message for configuration
public struct Skyle_Options {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Turn on an image stream @ http://skyle.local:8080
  public var stream: Bool = false

  ///Allow pause by API or by looking into the camera for 5 seconds
  public var enablePause: Bool = false

  ///Pause the eye tracker - enablePause needs to be true
  public var pause: Bool = false

  ///Deprecated: stream a positioning stream instead of an image stream (DO NOT USE)
  public var guidance: Bool = false

  ///Enable standby mode if the host (iPad) is not reachable / turned off
  public var enableStandby: Bool = false

  ///Disable mouse on windows or testing systems
  public var disableMouse: Bool = false

  ///Filter options for high skilled users, leave empty if skill is not high!
  public var filter: Skyle_FilterOptions {
    get {return _filter ?? Skyle_FilterOptions()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  ///Optional iPad Pro Settings, leave empty when unused / not sending
  public var iPadOptions: Skyle_IPadOptions {
    get {return _iPadOptions ?? Skyle_IPadOptions()}
    set {_iPadOptions = newValue}
  }
  /// Returns true if `iPadOptions` has been explicitly set.
  public var hasIPadOptions: Bool {return self._iPadOptions != nil}
  /// Clears the value of `iPadOptions`. Subsequent reads from it will return its default value.
  public mutating func clearIPadOptions() {self._iPadOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: Skyle_FilterOptions? = nil
  fileprivate var _iPadOptions: Skyle_IPadOptions? = nil
}

///*
/// iPad Option message for configuration
public struct Skyle_IPadOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Set this to true if iOS 13 to 13.3 is used, otherwise false (>= 13.4)
  public var isOldiOs: Bool = false

  ///Set this to true if screen zoom is not enabled. It is recommended to use zoom!
  public var isNotZommed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Message containing all build versions
public struct Skyle_DeviceVersions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Version of the firmware
  public var firmware: String = String()

  ///Version of the eye tracking software
  public var eyetracker: String = String()

  ///Version of the calibration software
  public var calib: String = String()

  ///Version of the base system
  public var base: String = String()

  ///Unique serial of this device
  public var serial: UInt64 = 0

  ///Product type: 4 means iPad version, 1 means developer or windows version
  public var skyleType: Int32 = 0

  ///Indicator if this is a demo device
  public var isDemo: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Representing the three available button actions 
public struct Skyle_ButtonActions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Action to trigger, when a single click on the button is performed
  public var singleClick: String = String()

  ///Action to trigger, when a double click on the button is performed
  public var doubleClick: String = String()

  ///Action to trigger when the button is constantly pushed
  public var holdClick: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Button message
public struct Skyle_Button {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Indicates if a button is connected to the eye tracker
  public var isPresent: Bool = false

  ///Configured button actions
  public var buttonActions: Skyle_ButtonActions {
    get {return _buttonActions ?? Skyle_ButtonActions()}
    set {_buttonActions = newValue}
  }
  /// Returns true if `buttonActions` has been explicitly set.
  public var hasButtonActions: Bool {return self._buttonActions != nil}
  /// Clears the value of `buttonActions`. Subsequent reads from it will return its default value.
  public mutating func clearButtonActions() {self._buttonActions = nil}

  ///List with available actions, currently: "none", "unknown", "leftClick", "rightClick", "scroll", "calibrate"
  public var availableActions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _buttonActions: Skyle_ButtonActions? = nil
}

///*
/// Filter configuration message
public struct Skyle_FilterOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Filter for fixations. range is 3 to 33 (3 high speed, less filtering and 33 low speed, hard filtering)
  public var fixationFilter: Int32 = 0

  ///Filter for gaze. range is 3 to 33 (3 high speed, less filtering and 33 low speed, hard filtering)
  public var gazeFilter: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Skyle"

extension Skyle_ResetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services"),
    2: .same(proto: "device"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.services)
      case 2: try decoder.decodeSingularBoolField(value: &self.device)
      case 3: try decoder.decodeSingularBoolField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.services != false {
      try visitor.visitSingularBoolField(value: self.services, fieldNumber: 1)
    }
    if self.device != false {
      try visitor.visitSingularBoolField(value: self.device, fieldNumber: 2)
    }
    if self.data != false {
      try visitor.visitSingularBoolField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_ResetMessage, rhs: Skyle_ResetMessage) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.device != rhs.device {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Profile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "name"),
    3: .same(proto: "skill"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularEnumField(value: &self.skill)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.skill != .low {
      try visitor.visitSingularEnumField(value: self.skill, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_Profile, rhs: Skyle_Profile) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.skill != rhs.skill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_Profile.Skill: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Low"),
    1: .same(proto: "Medium"),
    2: .same(proto: "High"),
  ]
}

extension Skyle_StatusMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_StatusMessage, rhs: Skyle_StatusMessage) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_OptionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "empty"),
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .empty(v)}
      case 2:
        var v: Skyle_Options?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .options(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .options(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.message {
    case .empty(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .options(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_OptionMessage, rhs: Skyle_OptionMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_calibControlMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".calibControlMessages"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calibControl"),
    2: .same(proto: "calibImprove"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Skyle_CalibControl?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .calibControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .calibControl(v)}
      case 2:
        var v: Skyle_CalibImprove?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .calibImprove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .calibImprove(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.message {
    case .calibControl(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .calibImprove(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_calibControlMessages, rhs: Skyle_calibControlMessages) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_CalibControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CalibControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calibrate"),
    2: .same(proto: "numberOfPoints"),
    3: .same(proto: "abort"),
    4: .same(proto: "stopHID"),
    5: .same(proto: "res"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.calibrate)
      case 2: try decoder.decodeSingularInt32Field(value: &self.numberOfPoints)
      case 3: try decoder.decodeSingularBoolField(value: &self.abort)
      case 4: try decoder.decodeSingularBoolField(value: &self.stopHid)
      case 5: try decoder.decodeSingularMessageField(value: &self._res)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.calibrate != false {
      try visitor.visitSingularBoolField(value: self.calibrate, fieldNumber: 1)
    }
    if self.numberOfPoints != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfPoints, fieldNumber: 2)
    }
    if self.abort != false {
      try visitor.visitSingularBoolField(value: self.abort, fieldNumber: 3)
    }
    if self.stopHid != false {
      try visitor.visitSingularBoolField(value: self.stopHid, fieldNumber: 4)
    }
    if let v = self._res {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_CalibControl, rhs: Skyle_CalibControl) -> Bool {
    if lhs.calibrate != rhs.calibrate {return false}
    if lhs.numberOfPoints != rhs.numberOfPoints {return false}
    if lhs.abort != rhs.abort {return false}
    if lhs.stopHid != rhs.stopHid {return false}
    if lhs._res != rhs._res {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_ScreenResolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScreenResolution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "width"),
    6: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 5: try decoder.decodeSingularInt32Field(value: &self.width)
      case 6: try decoder.decodeSingularInt32Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_ScreenResolution, rhs: Skyle_ScreenResolution) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_CalibImprove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CalibImprove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rating"),
    2: .same(proto: "stopHID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.rating)
      case 2: try decoder.decodeSingularBoolField(value: &self.stopHid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rating != 0 {
      try visitor.visitSingularInt32Field(value: self.rating, fieldNumber: 1)
    }
    if self.stopHid != false {
      try visitor.visitSingularBoolField(value: self.stopHid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_CalibImprove, rhs: Skyle_CalibImprove) -> Bool {
    if lhs.rating != rhs.rating {return false}
    if lhs.stopHid != rhs.stopHid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_CalibMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CalibMessages"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calibControl"),
    2: .same(proto: "calibPoint"),
    3: .same(proto: "calibQuality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Skyle_CalibControl?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .calibControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .calibControl(v)}
      case 2:
        var v: Skyle_CalibPoint?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .calibPoint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .calibPoint(v)}
      case 3:
        var v: Skyle_CalibQuality?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .calibQuality(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .calibQuality(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.message {
    case .calibControl(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .calibPoint(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .calibQuality(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_CalibMessages, rhs: Skyle_CalibMessages) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_Point, rhs: Skyle_Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_CalibPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CalibPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "currentPoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.count)
      case 2: try decoder.decodeSingularMessageField(value: &self._currentPoint)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 1)
    }
    if let v = self._currentPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_CalibPoint, rhs: Skyle_CalibPoint) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs._currentPoint != rhs._currentPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_CalibQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CalibQuality"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quality"),
    2: .same(proto: "qualitys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.quality)
      case 2: try decoder.decodeRepeatedDoubleField(value: &self.qualitys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quality != 0 {
      try visitor.visitSingularDoubleField(value: self.quality, fieldNumber: 1)
    }
    if !self.qualitys.isEmpty {
      try visitor.visitPackedDoubleField(value: self.qualitys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_CalibQuality, rhs: Skyle_CalibQuality) -> Bool {
    if lhs.quality != rhs.quality {return false}
    if lhs.qualitys != rhs.qualitys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_PositioningMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositioningMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "leftEye"),
    2: .same(proto: "rightEye"),
    3: .same(proto: "qualityDepth"),
    4: .same(proto: "qualitySides"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._leftEye)
      case 2: try decoder.decodeSingularMessageField(value: &self._rightEye)
      case 3: try decoder.decodeSingularInt32Field(value: &self.qualityDepth)
      case 4: try decoder.decodeSingularInt32Field(value: &self.qualitySides)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._leftEye {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._rightEye {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.qualityDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.qualityDepth, fieldNumber: 3)
    }
    if self.qualitySides != 0 {
      try visitor.visitSingularInt32Field(value: self.qualitySides, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_PositioningMessage, rhs: Skyle_PositioningMessage) -> Bool {
    if lhs._leftEye != rhs._leftEye {return false}
    if lhs._rightEye != rhs._rightEye {return false}
    if lhs.qualityDepth != rhs.qualityDepth {return false}
    if lhs.qualitySides != rhs.qualitySides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .same(proto: "enablePause"),
    3: .same(proto: "pause"),
    4: .same(proto: "guidance"),
    5: .same(proto: "enableStandby"),
    6: .same(proto: "disableMouse"),
    7: .same(proto: "filter"),
    8: .same(proto: "iPadOptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.stream)
      case 2: try decoder.decodeSingularBoolField(value: &self.enablePause)
      case 3: try decoder.decodeSingularBoolField(value: &self.pause)
      case 4: try decoder.decodeSingularBoolField(value: &self.guidance)
      case 5: try decoder.decodeSingularBoolField(value: &self.enableStandby)
      case 6: try decoder.decodeSingularBoolField(value: &self.disableMouse)
      case 7: try decoder.decodeSingularMessageField(value: &self._filter)
      case 8: try decoder.decodeSingularMessageField(value: &self._iPadOptions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stream != false {
      try visitor.visitSingularBoolField(value: self.stream, fieldNumber: 1)
    }
    if self.enablePause != false {
      try visitor.visitSingularBoolField(value: self.enablePause, fieldNumber: 2)
    }
    if self.pause != false {
      try visitor.visitSingularBoolField(value: self.pause, fieldNumber: 3)
    }
    if self.guidance != false {
      try visitor.visitSingularBoolField(value: self.guidance, fieldNumber: 4)
    }
    if self.enableStandby != false {
      try visitor.visitSingularBoolField(value: self.enableStandby, fieldNumber: 5)
    }
    if self.disableMouse != false {
      try visitor.visitSingularBoolField(value: self.disableMouse, fieldNumber: 6)
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._iPadOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_Options, rhs: Skyle_Options) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.enablePause != rhs.enablePause {return false}
    if lhs.pause != rhs.pause {return false}
    if lhs.guidance != rhs.guidance {return false}
    if lhs.enableStandby != rhs.enableStandby {return false}
    if lhs.disableMouse != rhs.disableMouse {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs._iPadOptions != rhs._iPadOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_IPadOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IPadOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isOldiOS"),
    2: .same(proto: "isNotZommed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isOldiOs)
      case 2: try decoder.decodeSingularBoolField(value: &self.isNotZommed)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isOldiOs != false {
      try visitor.visitSingularBoolField(value: self.isOldiOs, fieldNumber: 1)
    }
    if self.isNotZommed != false {
      try visitor.visitSingularBoolField(value: self.isNotZommed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_IPadOptions, rhs: Skyle_IPadOptions) -> Bool {
    if lhs.isOldiOs != rhs.isOldiOs {return false}
    if lhs.isNotZommed != rhs.isNotZommed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_DeviceVersions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceVersions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "firmware"),
    2: .same(proto: "eyetracker"),
    3: .same(proto: "calib"),
    4: .same(proto: "base"),
    5: .same(proto: "serial"),
    6: .same(proto: "skyleType"),
    7: .same(proto: "isDemo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.firmware)
      case 2: try decoder.decodeSingularStringField(value: &self.eyetracker)
      case 3: try decoder.decodeSingularStringField(value: &self.calib)
      case 4: try decoder.decodeSingularStringField(value: &self.base)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.serial)
      case 6: try decoder.decodeSingularInt32Field(value: &self.skyleType)
      case 7: try decoder.decodeSingularBoolField(value: &self.isDemo)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.firmware.isEmpty {
      try visitor.visitSingularStringField(value: self.firmware, fieldNumber: 1)
    }
    if !self.eyetracker.isEmpty {
      try visitor.visitSingularStringField(value: self.eyetracker, fieldNumber: 2)
    }
    if !self.calib.isEmpty {
      try visitor.visitSingularStringField(value: self.calib, fieldNumber: 3)
    }
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 4)
    }
    if self.serial != 0 {
      try visitor.visitSingularUInt64Field(value: self.serial, fieldNumber: 5)
    }
    if self.skyleType != 0 {
      try visitor.visitSingularInt32Field(value: self.skyleType, fieldNumber: 6)
    }
    if self.isDemo != false {
      try visitor.visitSingularBoolField(value: self.isDemo, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_DeviceVersions, rhs: Skyle_DeviceVersions) -> Bool {
    if lhs.firmware != rhs.firmware {return false}
    if lhs.eyetracker != rhs.eyetracker {return false}
    if lhs.calib != rhs.calib {return false}
    if lhs.base != rhs.base {return false}
    if lhs.serial != rhs.serial {return false}
    if lhs.skyleType != rhs.skyleType {return false}
    if lhs.isDemo != rhs.isDemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_ButtonActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ButtonActions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "singleClick"),
    2: .same(proto: "doubleClick"),
    3: .same(proto: "holdClick"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.singleClick)
      case 2: try decoder.decodeSingularStringField(value: &self.doubleClick)
      case 3: try decoder.decodeSingularStringField(value: &self.holdClick)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.singleClick.isEmpty {
      try visitor.visitSingularStringField(value: self.singleClick, fieldNumber: 1)
    }
    if !self.doubleClick.isEmpty {
      try visitor.visitSingularStringField(value: self.doubleClick, fieldNumber: 2)
    }
    if !self.holdClick.isEmpty {
      try visitor.visitSingularStringField(value: self.holdClick, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_ButtonActions, rhs: Skyle_ButtonActions) -> Bool {
    if lhs.singleClick != rhs.singleClick {return false}
    if lhs.doubleClick != rhs.doubleClick {return false}
    if lhs.holdClick != rhs.holdClick {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_Button: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Button"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isPresent"),
    2: .same(proto: "buttonActions"),
    3: .same(proto: "availableActions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isPresent)
      case 2: try decoder.decodeSingularMessageField(value: &self._buttonActions)
      case 3: try decoder.decodeRepeatedStringField(value: &self.availableActions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isPresent != false {
      try visitor.visitSingularBoolField(value: self.isPresent, fieldNumber: 1)
    }
    if let v = self._buttonActions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.availableActions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.availableActions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_Button, rhs: Skyle_Button) -> Bool {
    if lhs.isPresent != rhs.isPresent {return false}
    if lhs._buttonActions != rhs._buttonActions {return false}
    if lhs.availableActions != rhs.availableActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Skyle_FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fixationFilter"),
    2: .same(proto: "gazeFilter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.fixationFilter)
      case 2: try decoder.decodeSingularInt32Field(value: &self.gazeFilter)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fixationFilter != 0 {
      try visitor.visitSingularInt32Field(value: self.fixationFilter, fieldNumber: 1)
    }
    if self.gazeFilter != 0 {
      try visitor.visitSingularInt32Field(value: self.gazeFilter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Skyle_FilterOptions, rhs: Skyle_FilterOptions) -> Bool {
    if lhs.fixationFilter != rhs.fixationFilter {return false}
    if lhs.gazeFilter != rhs.gazeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
